# SSDT USB Mapping

My approach is utilizes SSDTs such as [SSDT-RHUB](https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-RHUB.dsl) and [SSDT-USB-Reset]() generated by USBMap. Advantage of this approach: No _UPC to XUPC rename!

### Overview
```asl
Device (HS01)
{
    Name (_ADR, One)  
    Name (_STA, 0x0F) 

    Method (_UPC, 0, Serialized)  // _UPC: USB Port Capabilities
    {
        Name (UPCP, Package (0x04) 
        {
            0xFF, // Determines if a port is on or off
            0x03, // Determines the type of port. 
            Zero, 
            Zero
        }
    /*
        Yours might have additional `If` statements in this part.
    */
        Return (UPCP) // Send the 4 packages from UPCP to _UPC
    }
}
```
`_UPC` needs this `Package` of `(0x04)`. This package to tells if ports is active, and its type. In my case, the package is within `UPCP`. Yours might be named differently, but the structure may look like this. 


<details>
    <summary>.</summary>
<table>
  <tr>
    <td>
      <table>
      <thead>
        <tr>
          <th>1st packet</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0x00 or Zero</td>
          <td>Off</td>
        </tr>
        <tr>
          <td>0xFF</td>
          <td>On</td>
        </tr>
      </tbody>
    </table>
    </td>
    <td>
        <table>
      <thead>
        <tr>
          <th>2nd packet</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0x00</td>
          <td>Type "A" Connector</td>
        </tr>
        <tr>
          <td>0x01</td>
          <td>Mini-AB Connector</td>
        </tr>
        <tr>
          <td>0x02</td>
          <td>ExpressCard USB Smart Card</td>
        </tr>
        <tr>
          <td>0x03</td>
          <td>USB3 Standard A Connector</td>
        </tr>
        <tr>
          <td>0x04</td>
          <td>USB3 Standard B Connector</td>
        </tr>
        <tr>
          <td>0x05</td>
          <td>USB3 Micro-B Connector</td>
        </tr>
        <tr>
          <td>0x06</td>
          <td>USB3 Micro-AB Connector</td>
        </tr>
        <tr>
          <td>0x07</td>
          <td>USB3 Micro-B Connector</td>
        </tr>
        <tr>
          <td>0x08</td>
          <td>USB Type-C (USB 2.0 Only)</td>
        </tr>
        <tr>
          <td>0x09</td>
          <td>USB Type-C (with Orientation)</td>
        </tr>
        <tr>
          <td>0x0A</td>
          <td>USB Type-C (without Orientation)</td>
        </tr>
        <tr>
          <td>0xFF</td>
          <td>Internal</td>
        </tr>
      </tbody>
    </table>
    </td>
  </tr>
</table>
</details>

# The Idea
According to the Dortania guide, some USB devices needs to be renamed. The approach of USBMap to rename EHC1 to EH01 is to disable EHC1, and add a new device EH01, then assign the _ADR of EHC1 to the EH01.

USBMap had generated me this SSDT.

```asl
DefinitionBlock ("", "SSDT", 2, "CORP", "UsbReset", 0x00001000)
{
    External (_SB.PCI0, DeviceObj)
    External (_SB.PCI0.EHC1, DeviceObj)

    Scope(_SB.PCI0.EHC1)
    {
        Method (_STA, 0, NotSerialized)  
        {
            If (_OSI ("Darwin"))
            {
                Return (Zero) // Disable EHC1 if macOS
            }
            Else
            {
                Return (0x0F) // Enble EHC1 if not macOS
            }
        }
    }

    Scope(_SB.PCI0)
    {
        Device (EH01)
        {
            Name (_ADR, 0x001D0000)  // Assigning the address of EHC1 to EH01
            Method (_STA, 0, NotSerialized) 
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F) // If macOS enable
                }
                Else
                {
                    Return (Zero) // If NOT macOS, disable
                }
            }
        }
    }
}
```

While the original EHC1 is disabled, **and so it's child devices**. So let's just add new ports to the EH01, while retaining the original `_ADR` of the ports from EHC1 to the new ports in EH01. EHC1 has a HUB device named `HUBN`, and the under this `HUBN`, there are the ports.

Under EH01, we will append these devices and their `_ADR`

```asl
Device (HUBN) // Reintroduce HUBN
{
    Name (_ADR, Zero)  // The _ADR of the original HUBN within EHC1
    Device (PR01)
    {
        Name (_ADR, One)  // The _ADR of the original PR01 within EHC1
        Method (_UPC, 0, Serialized) 
        {
            Name (GUPC, Package (0x04)
            {
                0xFF, // Active
                0x03, // Internal
                Zero, 
                Zero
            })
             Return (GUPC) 
            }
        }
        /*
            Append if there are ports within PR01
        */
    }
    /*
        Append if there are another port within HUBN
    */
}

```
You don't need to do this to every port present in DSDT. Just add the active ports.

### XHC
For XHC, there is the SSDT-RHUB

```asl
DefinitionBlock ("", "SSDT", 2, "DRTNIA", "RhubOff", 0x00001000)
{
    External (_SB_.PCI0.XHC.RHUB, DeviceObj) // Full pathing to RHUB, change to yours


    Scope (_SB.PCI0.XHC.RHUB) // Full pathing to RHUB, change to yours
        {
            Method (_STA, 0, NotSerialized)
            {
               If (_OSI ("Darwin"))
                     {
                        Return (Zero) // This disables the device only in macOS
                     }
                     Else
                     {
                        Return (0x0F) // Re-enables it for Windows
                     }
            }                    
        }  
}
```
The idea is the same, since RHUB is disabled, just introduce a new hub, I decided to name it `XHUB`, and then add new devices within it, and their `_ADR`.

```asl
DefinitionBlock ("", "SSDT", 2, "XXXXXXX", "XXXXXXX", 0x00001000)
{
    External (_SB_.PCI0.XHC) // XHC Path

    Scope (_SB.PCI0.XHC) // XHC Path
    {
        Device (XHUB) // Reintroducing a new HUB
        {
            Name (_ADR, Zero)  // _ADR: Address of RHUB in DSDT
            Method (_STA, 0, NotSerialized)
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F) // Only enable if macOS
                }
                Else
                {
                    Return (Zero) // Disable for other OS
                }
            }
            Device (HS01) // Reintroducing HS01
            {
                Name (_ADR, One)  // _ADR: Address of HS01 in DSDT
                Method (_UPC, 0, Serialized) 
                {
                    Name (GUPC, Package (0x04)
                    {
                        0xFF, // Active
                        0x02, // USB 2.0
                        Zero, 
                        Zero
                    })
                    Return (GUPC) 
                }
            }
            /*
                Append if there are another port within HUBN
            */
        }                    
    }  
}
```

Note:
* For `_PLD`, I didn't have to add this, port works okay with or without this. I am not sure if this exist in real macs ACPI.
* This could be so wrong, it just happens to work for me.

