
# Mapping USB ports via ACPI without Replacement table
> [!NOTE]  
>  Disclaimer: I am not a developer, and my knowledge of ACPI is limited. This might, or **MIGHT NOT** conform to ACPI specification.

### About
Majority of the ACPI USB mapping out there utilizes `_UPC` to `XUPC` renames that is quite confusing and hard to follow. This method is built above, and inspired with SSDTs such as [SSDT-RHUB](https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-RHUB.dsl) and **SSDT-USB-Reset** generated by USBMap. 



Advantage of this approach:

* macOS independent
* No _UPC to XUPC rename! ðŸŽ‰



### Overview
Every port in DSDT (or SSDT) has a `_UPC` method. `_UPC` needs this `Package` of four data. This package to tells if port is active, and its type. In my case, the package is within `UPCP`. Yours might be named differently, but the structure may look like this. 

```asl
Device (HS01) // The USB Port
{
    Name (_ADR, One)  // The address of HS01
    Name (_STA, 0x0F) 

    Method (_UPC, 0, Serialized)  // _UPC: USB Port Capabilities
    {
        Name (UPCP, Package (0x04) 
        {
            0xFF, // Determines if a port is on or off | 0xFF = On /  Zero = Off
            0x03, // Determines the type of port. 
            Zero, 
            Zero
        })
    /*
        Yours might have additional `If` statements in this part.
    */
        Return (UPCP) // Send the 4 data from `UPCP` to `_UPC`
    }
}
```
The following values for USB port types are possible:

| Value  | Port Type |       
| :----: | ----------|
|**`0X00`**| USB Type `A` |
|**`0x01`**| USB `Mini-AB` |
|**`0x02`**| USB Smart Card |
|**`0x03`**| USB 3 Standard Type `A` |
|**`0x04`**| USB 3 Standard Type `B` |
|**`0x05`**| USB 3 `Micro-B` |
|**`0x06`**| USB 3 `Micro-AB` |
|**`0x07`**| USB 3 `Power-B` |
|**`0x08`**| USB Type `C` (USB 2 only) |
|**`0x09`**| USB Type `C` (with Switch) | 
|**`0x0A`**| USB Type `C` (w/o Switch) | 
|**`0xFF`**| Internal USB 2 port|

The most connector types nowadays are:

| Value  | Port Type |       
| :----: | ----------|
|**`0X00`**| USB 2, Type `A` |
|**`0x03`**| USB 3, Type `A` |
|**`0x09`**| USB Type `C` (with Switch) | 
|**`0x0A`**| USB Type `C` (w/o Switch) | 
|**`0xFF`**| Internal USB 2 port (for Bluetooth connectors)|

# Background
According to the Dortania's [OpenCore Install Guide](https://dortania.github.io/OpenCore-Post-Install/usb/system-preparation.html#checking-what-renames-you-need), some USB devices needs to be renamed. 

### I. Rename via config.plist 
Dortania reccomends by adding these renames under ACPI -> Patch of your config.plist.

* **XHC1 to SHCI**: Needed for Skylake and older SMBIOS

| Key | Type | Value |
| :--- | :--- | :--- |
| Comment | String | XHC1 to SHCI |
| Count | Number | 0 |
| Enabled | Boolean | YES |
| Find | Data | 58484331 |
| Limit | Number | 0 |
| Replace | Data | 53484349 |
| Skip | Number | 0 |
| TableLength | Number | 0 |
| TableSignature | Data |  |

* **EHC1 to EH01**: Needed for Broadwell and older SMBIOS

| Key | Type | Value |
| :--- | :--- | :--- |
| Comment | String | EHC1 to EH01 |
| Count | Number | 0 |
| Enabled | Boolean | YES |
| Find | Data | 45484331 |
| Limit | Number | 0 |
| Replace | Data | 45483031 |
| Skip | Number | 0 |
| TableLength | Number | 0 |
| TableSignature | Data |  |

* **EHC2 to EH02**: Needed for Broadwell and older SMBIOS

| Key | Type | Value |
| :--- | :--- | :--- |
| Comment | String | EHC2 to EH02 |
| Count | Number | 0 |
| Enabled | Boolean | YES |
| Find | Data | 45484332 |
| Limit | Number | 0 |
| Replace | Data | 45483032 |
| Skip | Number | 0 |
| TableLength | Number | 0 |
| TableSignature | Data |  |


### II. Rename via SSDT 

USBMap has a different approach in renaming EHC1 to EH01. It disables EHC1 and then add a new device EH01, then take the `_ADR` of EHC1 and assign it to the EH01.

Sample: USBMap had generated me this SSDT.

```asl
DefinitionBlock ("", "SSDT", 2, "CORP", "UsbReset", 0x00001000)
{
    External (_SB.PCI0, DeviceObj)
    External (_SB.PCI0.EHC1, DeviceObj)

    Scope (_SB.PCI0.EHC1) // referencing EHC1 in DSDT
    {
        Method (_STA, 0, NotSerialized)  
        {
            If (_OSI ("Darwin"))
            {
                Return (Zero) // Disable EHC1 if macOS
            }
            Else
            {
                Return (0x0F) // Enble EHC1 if not macOS
            }
        }
    }

    Scope (_SB.PCI0)
    {
        Device (EH01) // Reintroducing EHC but in a new name
        {
            Name (_ADR, 0x001D0000)  // Assigning the address of EHC1 (from DSDT) to EH01
            Method (_STA, 0, NotSerialized) 
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F) // If macOS enable
                }
                Else
                {
                    Return (Zero) // If NOT macOS, disable
                }
            }
        }
    }
}
```

In the above:

* If macOS: EHC1 is disabled. This also disables device and methods under it - which are the HUB device, the ports, and their `_UPC` methods.
* EH01 is also being introduced with the `_ADR` of the of EHC1 taken from DSDT.


### XHC
For XHC, there is the SSDT-RHUB. Pasting just for reference, not related from above.

```asl
DefinitionBlock ("", "SSDT", 2, "DRTNIA", "RhubOff", 0x00001000)
{
    External (_SB_.PCI0.XHC.RHUB, DeviceObj) // Full pathing to RHUB, change to yours


    Scope (_SB.PCI0.XHC.RHUB) // Full pathing to RHUB, change to yours
        {
            Method (_STA, 0, NotSerialized)
            {
               If (_OSI ("Darwin"))
                     {
                        Return (Zero) // This disables the device only in macOS
                     }
                     Else
                     {
                        Return (0x0F) // Re-enables it for Windows
                     }
            }                    
        }  
}
```



## The Idea

Take away from **SSDT-USB-Reset**: If you can rename an EHC1 by disabling it, and then re-introducing a EH01 but with the `_ADR` of the actual EHC1. Why not also do it for it's hub and ports.

Take away from  **SSDT-RHUB**, since it disables the RHUB, this also disables it's ports and their `_UPC` methods. So we will just introduce a new hub instead. Name it something like `XHUB`, and then enumerate the ports within it. Take each `_ADR` from the original from the RHUB and it's ports in DSDT.

> [!NOTE]
> This approach is not endorsed or recommended by Dortania's Install Guide, or CorpNewt - the creator of the USBMap tool. I just repurposed their existing method for this specific purpose.

## Guide
This guide assumes you already know which parts are active, and their port type.

1. If you have the USB controllers that needed renames, do the ACPI -> Patch rename first.


### For SHCI, and EH01/EH02:
* Make sure the `Scope` and `External` for the RHUB/HUBN is same as the renamed one instead of the original name - because OpenCore does renaming first before adding the custom SSDT. 
	* If you renamed from `XHCI` to `SHCI`, then the reference will be something like `_SB_.PCI0.SHCI.RHUB` not the original name.
 
```asl
DefinitionBlock ("", "SSDT", 2, "USBMAP", "USBMAP", 0x00001000)
{
    External (_SB_.PCI0.XHC.RHUB, DeviceObj) // Full pathing to RHUB, change to yours


    Scope (_SB.PCI0.XHC.RHUB) // Full pathing to RHUB, change to yours
        {
            Method (_STA, 0, NotSerialized)
            {
               If (_OSI ("Darwin"))
                     {
                        Return (Zero) // This disables the device only in macOS
                     }
                     Else
                     {
                        Return (0x0F) // Re-enables it for Windows
                     }
            }                    
        }
        
        
    Scope (_SB.PCI0.XHC) // XHC Path
    {
        Device (XHUB) // Reintroducing a new HUB
        {
            Name (_ADR, Zero)  // _ADR: Address of RHUB in DSDT
            Method (_STA, 0, NotSerialized)
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F) // Only enable if macOS
                }
                Else
                {
                    Return (Zero) // Disable for other OS
                }
            }
            Device (HS01) // Reintroducing HS01
            {
                Name (_ADR, One)  // _ADR: Address of HS01 in DSDT
                Method (_UPC, 0, Serialized) 
                {
                    Name (GUPC, Package (0x04)
                    {
                        0xFF, // Active
                        0x00, // USB 2.0
                        Zero, 
                        Zero
                    })
                    Return (GUPC) 
                }
            }
            /*
                Append if there are another port within RHUB.
                You don't need every port present in DSDT. Just add the active ports.
            */
        }                    
    }  
}
```
> This `.aml` is based on SSDT-RHUB, SSDT-USB-Reset, and the GUPC method. The whole idea of this guide is just disable the HUB under these USB controllers, and then introduce a new one with the `_ADR` of the original devices in DSDT/SSDT

## Notes
* `_PLD` methods exist under these ports in DSDT. I didn't have to add this, port works okay with or without this. I am not sure if it exists in real macs ACPI.
* Why not follow what **SSDT-USB-Reset** does in renaming USB controllers instead of `ACPI` -> `Patch`? 
	* For instance, if I disable XHCI and introduce SHCI (with `_ADR`  XHCI), this also disables other methods under XHCI. I feel like it's safer to disable the Hub instead of the device, meaning renaming `XHCI` to `SHCI` remains these methods intact in the original DSDT/SSDT, and such [patch](https://dortania.github.io/OpenCore-Post-Install/usb/misc/shutdown.html) could still work correctly.
   
* Aside from `_UPC`, if (maybe) the `_ADR` of each port is also borked in your ACPI. Just analyze their real address in IORegExplorer.
	* The value (e.g. 0x14320000) is represented as follows: 0xAA**B**CDEFG [(Reference)](https://github.com/benbaker76/Hackintool/issues/39#issuecomment-581023453)
		* AA - Ctrl number 8 bits (e.g. 0x14, aka XHCI)
		* B - Port number 4 bits (e.g. 0x3, aka SS03)
		* C ~ F - Bus number 4 bits (e.g. 0x2, aka IOUSBHostHIDDevice)
		* C ~ F are filled as many times as many USB Hubs are there on the port.
			* ie.
				* XHCI - 0x14**x**xxxxx
				* EHx1 - 0x1D**x**xxxxx
				* EHx2 - 0x1A**x**xxxxx
    	* For instance, HS05's Location ID is <code>0x14<b>5</b>00000</code>, the `5` is the `_ADR` of this port, meaning `Name (_ADR, 0x05)`.



* Some information are based on the [ACPI_Mapping_USB_Ports/GUPC_Method](https://github.com/5T33Z0/OC-Little-Translated/tree/main/03_USB_Fixes/ACPI_Mapping_USB_Ports/GUPC_Method) of 5T33Z0/OC-Little-Translated guide, and the Dortania install guide.
