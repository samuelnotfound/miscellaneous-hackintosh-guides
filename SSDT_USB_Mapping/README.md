Some information are based on the [ACPI_Mapping_USB_Ports/GUPC_Method](https://github.com/5T33Z0/OC-Little-Translated/tree/main/03_USB_Fixes/ACPI_Mapping_USB_Ports/GUPC_Method) of 5T33Z0/OC-Little-Translated guide.

 > Disclaimer: I am not a developer, and my knowledge of ACPI is limited. This might OR might not conform to ACPI specification.
 

# Mapping USB ports via ACPI without Replacement table
My approach untilizes,and built above SSDTs such as [SSDT-RHUB](https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-RHUB.dsl) and **SSDT-USB-Reset** generated by USBMap. 




Advantage of this approach:

* macOS independent
* No _UPC to XUPC rename! ðŸŽ‰



### Overview
Every port in DSDT (or SSDT) has a `_UPC` method. `_UPC` needs this `Package` of four data. This package to tells if port is active, and its type. In my case, the package is within `UPCP`. Yours might be named differently, but the structure may look like this. 

```asl
Device (HS01) // The USB Port
{
    Name (_ADR, One)  
    Name (_STA, 0x0F) 

    Method (_UPC, 0, Serialized)  // _UPC: USB Port Capabilities
    {
        Name (UPCP, Package (0x04) 
        {
            0xFF, // Determines if a port is on or off
            0x03, // Determines the type of port. 
            Zero, 
            Zero
        })
    /*
        Yours might have additional `If` statements in this part.
    */
        Return (UPCP) // Send the 4 data from `UPCP` to `_UPC`
    }
}
```


# Background
According to the Dortania guide, some USB devices needs to be renamed. 

### I. Rename via config.plist 
Dortania reccomends by adding these renames under ACPI -> Patch of your config.plist.

* **XHC1 to SHCI**: Needed for Skylake and older SMBIOS

| Key | Type | Value |
| :--- | :--- | :--- |
| Comment | String | XHC1 to SHCI |
| Count | Number | 0 |
| Enabled | Boolean | YES |
| Find | Data | 58484331 |
| Limit | Number | 0 |
| Replace | Data | 53484349 |
| Skip | Number | 0 |
| TableLength | Number | 0 |
| TableSignature | Data |  |

* **EHC1 to EH01**: Needed for Broadwell and older SMBIOS

| Key | Type | Value |
| :--- | :--- | :--- |
| Comment | String | EHC1 to EH01 |
| Count | Number | 0 |
| Enabled | Boolean | YES |
| Find | Data | 45484331 |
| Limit | Number | 0 |
| Replace | Data | 45483031 |
| Skip | Number | 0 |
| TableLength | Number | 0 |
| TableSignature | Data |  |

* **EHC2 to EH02**: Needed for Broadwell and older SMBIOS

| Key | Type | Value |
| :--- | :--- | :--- |
| Comment | String | EHC2 to EH02 |
| Count | Number | 0 |
| Enabled | Boolean | YES |
| Find | Data | 45484332 |
| Limit | Number | 0 |
| Replace | Data | 45483032 |
| Skip | Number | 0 |
| TableLength | Number | 0 |
| TableSignature | Data |  |


### II. Rename via SSDT 

USBMap has a different approach in renaming EHC1 to EH01. It disables EHC1 and then add a new device EH01, then take the `_ADR` of EHC1 and assign it to the EH01.

Sample: USBMap had generated me this SSDT.

```asl
DefinitionBlock ("", "SSDT", 2, "CORP", "UsbReset", 0x00001000)
{
    External (_SB.PCI0, DeviceObj)
    External (_SB.PCI0.EHC1, DeviceObj)

    Scope (_SB.PCI0.EHC1) // referencing EHC1 in DSDT
    {
        Method (_STA, 0, NotSerialized)  
        {
            If (_OSI ("Darwin"))
            {
                Return (Zero) // Disable EHC1 if macOS
            }
            Else
            {
                Return (0x0F) // Enble EHC1 if not macOS
            }
        }
    }

    Scope (_SB.PCI0)
    {
        Device (EH01) // Reintroducing EHC but in a new name
        {
            Name (_ADR, 0x001D0000)  // Assigning the address of EHC1 to EH01
            Method (_STA, 0, NotSerialized) 
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F) // If macOS enable
                }
                Else
                {
                    Return (Zero) // If NOT macOS, disable
                }
            }
        }
    }
}
```

In the above:

* If macOS: EHC1 is disabled. This also disables device and methods under it - which are the HUB device, the ports, and their `_UPC` methods.
* EH01 is also being introduced with the `_ADR` of the of EHC1 taken from DSDT.


### XHC
For XHC, there is the SSDT-RHUB. Pasting just for reference, not related from above.

```asl
DefinitionBlock ("", "SSDT", 2, "DRTNIA", "RhubOff", 0x00001000)
{
    External (_SB_.PCI0.XHC.RHUB, DeviceObj) // Full pathing to RHUB, change to yours


    Scope (_SB.PCI0.XHC.RHUB) // Full pathing to RHUB, change to yours
        {
            Method (_STA, 0, NotSerialized)
            {
               If (_OSI ("Darwin"))
                     {
                        Return (Zero) // This disables the device only in macOS
                     }
                     Else
                     {
                        Return (0x0F) // Re-enables it for Windows
                     }
            }                    
        }  
}
```



## The Idea:

Take away from **SSDT-USB-Reset**: If you can rename an EHC1 by disabling it, and then re-introducing a EH01 but with the `_ADR` of the actual EHC1. Why not also do it for it's hub and ports.

Take away from  **SSDT-RHUB**, since it disables the RHUB, this also disables it's ports and their `_UPC` methods. So we will just introduce a new hub instead. Name it something like `XHUB`, and then enumerate the ports within it. Take each `_ADR` from the original from the RHUB and it's ports in DSDT.


## Guide
1. If you have the USB controllers that needed renames, do the ACPI -> Patch rename first.


### For SHCI, and EH01/EH02:
* Make sure the `Scope` and `External` for the RHUB/HUBN is same as the renamed one instead of the original name - because OpenCore does renaming first before adding the custom SSDT. 
	* If you renamed from `XHCI` to `SHCI`, then the reference will be something like `_SB_.PCI0.SHCI.RHUB` not the original name.
 
```asl
DefinitionBlock ("", "SSDT", 2, "USBMAP", "USBMAP", 0x00001000)
{
    External (_SB_.PCI0.XHC.RHUB, DeviceObj) // Full pathing to RHUB, change to yours


    Scope (_SB.PCI0.XHC.RHUB) // Full pathing to RHUB, change to yours
        {
            Method (_STA, 0, NotSerialized)
            {
               If (_OSI ("Darwin"))
                     {
                        Return (Zero) // This disables the device only in macOS
                     }
                     Else
                     {
                        Return (0x0F) // Re-enables it for Windows
                     }
            }                    
        }
        
        
    Scope (_SB.PCI0.XHC) // XHC Path
    {
        Device (XHUB) // Reintroducing a new HUB
        {
            Name (_ADR, Zero)  // _ADR: Address of RHUB in DSDT
            Method (_STA, 0, NotSerialized)
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F) // Only enable if macOS
                }
                Else
                {
                    Return (Zero) // Disable for other OS
                }
            }
            Device (HS01) // Reintroducing HS01
            {
                Name (_ADR, One)  // _ADR: Address of HS01 in DSDT
                Method (_UPC, 0, Serialized) 
                {
                    Name (GUPC, Package (0x04)
                    {
                        0xFF, // Active
                        0x00, // USB 2.0
                        Zero, 
                        Zero
                    })
                    Return (GUPC) 
                }
            }
            /*
                Append if there are another port within RHUB.
                You don't need every port present in DSDT. Just add the active ports.
            */
        }                    
    }  
}
```
> This `.aml` is based on SSDT-RHUB, SSDT-USB-Reset, and the GUPC method. 

* The idea is just disable the HUBS under these USB controllers, and then introduce a new one with the `_ADR` of the original devices in DSDT/SSDT.
* Why not follow what **SSDT-USB-Reset** does in renaming USB controllers instead of ACPI -> Patch? 
	* For instance, if I disable XHCI and introduce SHCI (with `_ADR`  XHCI), this also disables other methods under XHCI. I feel like it's safer to disable the Hub instead of the device, meaning renaming `XHCI` to `SHCI` remains these methods intact in the original DSDT/SSDT.

* For `_PLD`, I didn't have to add this, port works okay with or without this. I am not sure if it exists in real macs ACPI.

