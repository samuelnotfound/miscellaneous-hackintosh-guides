# SSDT USB Mapping

My approach is utilizes SSDTs such as [SSDT-RHUB](https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/decompiled/SSDT-RHUB.dsl) and [SSDT-USB-Reset]() generated by USBMap. 

### Overview
```asl
Device (HS01)
{
    Name (_ADR, One)  
    Name (_STA, 0x0F) 

    Method (_UPC, 0, Serialized)  // _UPC: USB Port Capabilities
    {
        Name (UPCP, Package (0x04) 
        {
            0xFF, // Determines if a port is on or off
            0x03, // Determines the type of port. 
            Zero, 
            Zero
        }
    /*
        Yours might have additional `If` statements in this part.
    */
        Return (UPCP) // Send the 4 packages from UPCP to _UPC
    }
}
```
`_UPC` needs this `Package` of `(0x04)`. This package to tells if ports is active, and its type. In my case, the package is within `UPCP`. Yours might be named differently, but the structure may look like this. 


<details>
    <summary>More Details</summary>
<table>
  <tr>
    <td>
      <table>
      <thead>
        <tr>
          <th>1st packet</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0x00 or Zero</td>
          <td>Off</td>
        </tr>
        <tr>
          <td>0xFF</td>
          <td>On</td>
        </tr>
      </tbody>
    </table>
    </td>
    <td>
        <table>
      <thead>
        <tr>
          <th>2nd packet</th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>0x00</td>
          <td>Type "A" Connector</td>
        </tr>
        <tr>
          <td>0x01</td>
          <td>Mini-AB Connector</td>
        </tr>
        <tr>
          <td>0x02</td>
          <td>ExpressCard USB Smart Card</td>
        </tr>
        <tr>
          <td>0x03</td>
          <td>USB3 Standard A Connector</td>
        </tr>
        <tr>
          <td>0x04</td>
          <td>USB3 Standard B Connector</td>
        </tr>
        <tr>
          <td>0x05</td>
          <td>USB3 Micro-B Connector</td>
        </tr>
        <tr>
          <td>0x06</td>
          <td>USB3 Micro-AB Connector</td>
        </tr>
        <tr>
          <td>0x07</td>
          <td>USB3 Micro-B Connector</td>
        </tr>
        <tr>
          <td>0x08</td>
          <td>USB Type-C (USB 2.0 Only)</td>
        </tr>
        <tr>
          <td>0x09</td>
          <td>USB Type-C (with Orientation)</td>
        </tr>
        <tr>
          <td>0x0A</td>
          <td>USB Type-C (without Orientation)</td>
        </tr>
        <tr>
          <td>0xFF</td>
          <td>Internal</td>
        </tr>
      </tbody>
    </table>
    </td>
  </tr>
</table>
</details>

# Identify USB controller's ACPI path

According to the Dortania guide, some USB devices needs to be renamed to. The approach of USBMap to rename For EHC1 to EH01 is to disable EHC1, and add a new device EH01, then assign the _ADR of EHC1 to the EH01.

Lets find where the USB controller's location in ACPI.


![](/reference/ehc.png)
In my case, its \_SB.PCI0.EHC1



```asl
DefinitionBlock ("", "SSDT", 2, "CORP", "UsbReset", 0x00001000)
{
    External (_SB.PCI0, DeviceObj)
    External (_SB.PCI0.EHC1, DeviceObj)

    Scope(_SB.PCI0.EHC1)
    {
        Method (_STA, 0, NotSerialized)  
        {
            If (_OSI ("Darwin"))
            {
                Return (Zero)
            }
            Else
            {
                Return (0x0F)
            }
        }
    }

    Scope(_SB.PCI0)
    {
        Device (EH01)
        {
            Name (_ADR, 0x001D0000)  // Assigning the address of EHC1 to EH01
            Method (_STA, 0, NotSerialized) 
            {
                If (_OSI ("Darwin"))
                {
                    Return (0x0F)
                }
                Else
                {
                    Return (Zero)
                }
            }
        }
    }
}
```


Method 1: Easy way
Find the ACPI Path of your USB Controller device in your DSDT.

From the above, we can see that the full ACPI pathing for RHUB is PCI0.XHC.RHUB

In this part, we will disable the original EHC1, and then re-enable it with it back but with a different name. All methods and devices under EHC1 becomes will be disabled. So we will add it back.



For XHC
```asl
DefinitionBlock ("", "SSDT", 2, "DRTNIA", "RhubOff", 0x00001000)
{
    External (_SB_.PCI0.XHC.RHUB, DeviceObj) // Full pathing to RHUB, change to yours


    Scope (_SB.PCI0.XHC.RHUB) // Full pathing to RHUB, change to yours
        {
            Method (_STA, 0, NotSerialized)
            {
               If (_OSI ("Darwin"))
                     {
                        Return (Zero) // This disables the device only in macOS
                     }
                     Else
                     {
                        Return (0x0F) // Re-enables it for Windows
                     }
           }                    
        }  
}
```

